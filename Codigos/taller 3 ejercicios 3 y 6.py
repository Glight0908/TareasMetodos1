# -*- coding: utf-8 -*-
"""Ejercicios 3 y 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FXjWjzaE3Ktid-QUpyadTpJibETn8WxI
"""

import sympy as sp
from sympy import *
import numpy as np
import mpmath
from functools import lru_cache
from IPython.display import display, Math
import matplotlib.pyplot as plt

# Variable simbólica
x = sp.Symbol('x', real=True)

@lru_cache(maxsize=None)
def prod_int_Ch(f, g):
    return sp.integrate(f*g*sp.sqrt(1-x**2), (x, -1, 1))

@lru_cache(maxsize=None)
def prod_int_L(f, g):
    return sp.integrate(f*g, (x, -1, 1))

# ---------------------------
# Función Gram-Schmidt
# ---------------------------
def gram_schmidt(base, prod_int, ortonormal=True):
    """
    base: lista de funciones simbólicas
    prod_int: función de producto interno
    ortonormal: True para ortonormalizar, False para solo ortogonalizar
    """
    ortogonal = []
    normas = []

    for vi in base:
        wi = vi
        for u, nrm in zip(ortogonal, normas):
            wi -= prod_int(wi, u) / (nrm if not ortonormal else nrm**2) * u

        norma_wi = sp.sqrt(prod_int(wi, wi))

        if ortonormal:
            wi = wi / norma_wi
            normas.append(1)
        else:
            normas.append(norma_wi)

        ortogonal.append(sp.simplify(sp.expand(wi)))

    return ortogonal, normas

# ---------------------------
# Construcción de bases
# ---------------------------
n = 10
base = [x**i for i in range(n+1)]

# Base de Chebyshev
chebyshev, normas_Ch = gram_schmidt(base, prod_int_Ch, ortonormal=True)

# Base de Legendre
legendre, normas_L = gram_schmidt(base, prod_int_L, ortonormal=True)

# ---------------------------
# Mostrar resultados simplificados
# ---------------------------
for i, p in enumerate(chebyshev):
    display(Math(f"T_{{{i}}}(x) = {sp.latex(sp.simplify(sp.expand(p)))}"))

for i, p in enumerate(legendre):
    display(Math(f"P_{{{i}}}(x) = {sp.latex(sp.simplify(sp.expand(p)))}"))

# Definir la función objetivo
h = sp.sin(3*x) * (1 - x**2)


# Productos internos con la base original
proy_LM = [prod_int_L(h, p) for p in base]
producto_LM = [a*b for a, b in zip(base, proy_LM)]
print()
proy_L = [prod_int_L(h, p) for p in legendre]
producto_legendre = [a*b for a, b in zip(legendre, proy_L)]


expansion_legendre = sp.simplify(sum(producto_legendre))
expansion_LM =sp.simplify( sum(producto_LM))

producto_LM_simplificado = [sp.simplify(term) for term in producto_LM]
producto_legendre_simplificado = [sp.simplify(term) for term in producto_legendre]

# Mostrar resultados
display(Math(f"\\text{{Expansión en polinomios:}} {sp.latex(producto_LM_simplificado)}"))
print()
display(Math(f"\\text{{Expansión en polinomios de Legendre:}} {sp.latex(producto_legendre_simplificado)}"))
print()

#usamos integral numerica
@lru_cache(maxsize=None)
def prod_int_ChN(f, g):
    integrand = sp.lambdify(x, f*g*sp.sqrt(1-x**2), 'mpmath')
    return mpmath.quad(integrand, [-1, 1])

# Proyecciones con base de Chebyshev y su expansión
proy_Ch = [prod_int_ChN(h, p) for p in chebyshev]
producto_chebyshev = [a*b for a, b in zip(chebyshev, proy_Ch)]

# Expresión completa de la aproximación
aprox_chebyshev = sum(producto_chebyshev)

# Simplificar cada término
producto_chebyshev_simplificado = [sp.simplify(term) for term in producto_chebyshev]

# Mostrar expansión
display(Math(f"\\text{{Expansión en polinomios de Chebyshev:}} {sp.latex(producto_chebyshev_simplificado)}"))

#respectivamente esta Tn(x) que es el resultado del ejercicio 6 y el resto de resultados son del punto 3 em adelante

# Intervalo para graficar
X = np.linspace(-1, 1, 400)
Y_h = sp.lambdify(x, h, 'numpy')(X)

# Índices de cantidad de términos a mostrar
indices = [1, 3, 5, 7, 9, 11]

def evaluar_punto_a_punto(expr, X):
    """Evalúa una expresión simbólica en una lista de puntos"""
    f_num = sp.lambdify(x, expr, 'numpy')
    return np.array([float(f_num(xi)) for xi in X])

def graficar_parciales(producto, titulo):
    """Genera gráficas con aproximaciones parciales (k términos)"""
    plt.figure(figsize=(8, 6))
    plt.plot(X, Y_h, 'k', linewidth=2, label='h(x) Original')

    for k in indices:
        if k <= len(producto):
            parcial = sp.simplify(sum(producto[:k]))
            Y_parcial = evaluar_punto_a_punto(parcial, X)
            plt.plot(X, Y_parcial, linewidth=1.5, label=f'{k} términos')

    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(f'Aproximación progresiva - {titulo}')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Llamadas para cada tipo de base
graficar_parciales(producto_LM, "Base Monomial")
graficar_parciales(producto_legendre, "Polinomios de Legendre")
graficar_parciales(producto_chebyshev, "Polinomios de Chebyshev")

# Determinar el grado máximo en cada expansión
def grado_maximo(expresion):
    # Extrae el grado máximo del polinomio expandido
    return sp.degree(sp.expand(expresion), x)

grado_LM = grado_maximo(expansion_LM)
grado_leg = grado_maximo(expansion_legendre)
grado_cheb = grado_maximo(aprox_chebyshev)

print("Grado máximo en cada expansión:")
print(f"Base monomial: grado {grado_LM}")
print(f"Legendre: grado {grado_leg}")
print(f"Chebyshev: grado {grado_cheb}")

# Comparar coeficientes principales
coef_LM = sp.LC(sp.expand(expansion_LM))
coef_leg = sp.LC(sp.expand(expansion_legendre))
coef_cheb = sp.LC(sp.expand(aprox_chebyshev))

print("\nCoeficientes principales:")
print(f"Monomial: {coef_LM}")
print(f"Legendre: {coef_leg}")
print(f"Chebyshev: {coef_cheb}")

# Mostrar términos más altos en cada expansión
print("\nTérmino más alto en cada caso:")
print(f"Monomial: {sp.LT(sp.expand(expansion_LM))}")
print(f"Legendre: {sp.LT(sp.expand(expansion_legendre))}")
print(f"Chebyshev: {sp.LT(sp.expand(aprox_chebyshev))}")

indices = [1, 3, 5, 7, 9, 11]

# --- Calcular errores progresivos para cada método ---
errores_LM = []
errores_Legendre = []
errores_Chebyshev = []

for k in indices:
    # LM
    parcial_LM = sp.simplify(sum(producto_LM[:k]))
    err_LM = sp.sqrt(prod_int_L(h - parcial_LM, h - parcial_LM)).evalf()
    errores_LM.append(err_LM)

    # Legendre
    parcial_Leg = sp.simplify(sum(producto_legendre[:k]))
    err_Leg = sp.sqrt(prod_int_L(h - parcial_Leg, h - parcial_Leg)).evalf()
    errores_Legendre.append(err_Leg)

    # Chebyshev (numérico)
    parcial_Cheb = sp.simplify(sum(producto_chebyshev[:k]))
    err_Cheb = sp.sqrt(prod_int_ChN(h - parcial_Cheb, h - parcial_Cheb))
    errores_Chebyshev.append(err_Cheb)

# Mostrar resultados
for k, e_LM, e_Leg, e_Cheb in zip(indices, errores_LM, errores_Legendre, errores_Chebyshev):
    display(Math(f"\\text{{Error Monomios    (k={k}): }} {e_LM}"))
    display(Math(f"\\text{{Error Legendre   (k={k}): }}  {e_Leg}"))
    display(Math(f"\\text{{Error Chebyshev (k={k}): }} {e_Cheb}"))
    print()