# -*- coding: utf-8 -*-
"""codesheet taller 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cFTar94n3U1e5r1881LY58uZlNkPgRYT
"""

import sympy as sp

#ejercicio 3 (1.1.6)
def centroide_triangulo(a, b, c):
    """
    Calcula el centroide de un triángulo dados tres vectores posición.
    a, b, c deben ser vectores columna de SymPy.
    """
    return (a + b + c) / 3

# Definimos los vectores (puedes cambiar estos valores para cualquier caso)
a = sp.Matrix([1, 2, 3])
b = sp.Matrix([4, 5, 6])
c = sp.Matrix([7, 8, 9])

# Calculamos el centroide
g = centroide_triangulo(a, b, c)
print(f"Centroide g = ({g[0]}, {g[1]}, {g[2]})")

#ejercicio 6 (1.1.6)

# Definir símbolos
e1 = sp.Matrix([1, 0, 0])
e2 = sp.Matrix([0, 1, 0])
e3 = sp.Matrix([0, 0, 1])

# Definir vectores
a = e1 + 2*e2 + 3*e3
b = 4*e1 + 5*e2 + 6*e3
c = 3*e1 + 2*e2 + e3
d = 6*e1 + 5*e2 + 4*e3

# (a) Sumas
sum1 = a + b + c + d
sum2 = a + b - c - d
sum3 = a - b - c - d
sum4 = -a + b - c + d

# (b) Ángulos entre vectores y bases
def angle(u, v):
    return sp.acos((u.dot(v)) / (sp.sqrt(u.dot(u)) * sp.sqrt(v.dot(v))))

angles = {
    "a,b": angle(a, b),
    "a,c": angle(a, c),
    "a,d": angle(a, d),
    "b,c": angle(b, c),
    "b,d": angle(b, d),
    "c,d": angle(c, d),
    "a,e1": angle(a, e1),
    "a,e2": angle(a, e2),
    "a,e3": angle(a, e3),
    "b,e1": angle(b, e1),
    "b,e2": angle(b, e2),
    "b,e3": angle(b, e3),
    "c,e1": angle(c, e1),
    "c,e2": angle(c, e2),
    "c,e3": angle(c, e3),
    "d,e1": angle(d, e1),
    "d,e2": angle(d, e2),
    "d,e3": angle(d, e3)
}

# (c) Magnitudes
magnitudes = {
    "a": a.norm(),
    "b": b.norm(),
    "c": c.norm(),
    "d": d.norm()
}

# (d) Ángulo entre a y b y entre c y d
angle_ab = angle(a, b)
angle_cd = angle(c, d)

# (e) Proyección de a sobre b
proj_a_on_b = (a.dot(b) / b.dot(b)) * b

# (f) Coplanaridad (determinante triple)
coplanar = sp.Matrix.hstack(a, b, c).det() == 0

# (g) (a + b) · (c + d)
dot_sum = (a + b).dot(c + d)

# (h) Productos cruz y ángulos con d
axb = a.cross(b)
bxc = b.cross(c)
cxd = c.cross(d)

angles_with_d = {
    "a×b con d": angle(axb, d),
    "b×c con d": angle(bxc, d),
    "c×d con d": angle(cxd, d)
}

# (i) c · (a × b)
scalar_triple = c.dot(axb)

# Mostrar resultados
print("a) Sumas:")
print("a + b + c + d =", sum1)
print("a + b - c - d =", sum2)
print("a - b - c - d =", sum3)
print("-a + b - c + d =", sum4)

print("\nb) Ángulos (en radianes):")
for k, v in angles.items():
    print(f"ángulo {k} = {v}")

print("\nc) Magnitudes:")
for k, v in magnitudes.items():
    print(f"|{k}| = {v}")

print("\nd) Ángulo entre a y b =", angle_ab)
print("Ángulo entre c y d =", angle_cd)

print("\ne) Proyección de a sobre b =", proj_a_on_b)

print("\nf) ¿Son a, b, c coplanarios? =", coplanar)

print("\ng) (a + b) · (c + d) =", dot_sum)

print("\nh) Productos cruz y ángulos con d:")
print("a × b =", axb)
print("b × c =", bxc)
print("c × d =", cxd)
for k, v in angles_with_d.items():
    print(f"{k} = {v}")

print("\ni) c · (a × b) =", scalar_triple)

#ejercicio 13 (1.5.7)

# Variable
t = sp.symbols('t', real=True)

# Parametrización del círculo de radio 1
x = sp.cos(t)
y = sp.sin(t)

# Componentes del campo de fuerza
Fx = -y / (x**2 + y**2)
Fy =  x / (x**2 + y**2)

# Derivadas dx/dt y dy/dt
dx = sp.diff(x, t)
dy = sp.diff(y, t)

# Producto punto F·dr
integrando = sp.simplify(Fx*dx + Fy*dy)

# Integrales simbólicas
I_pos = sp.integrate(integrando, (t, 0, sp.pi))   # CCW
I_neg = sp.integrate(integrando, (t, 0, -sp.pi))  # CW

# Trabajo en contra del campo
W_pos = -I_pos
W_neg = -I_neg

# Resultados
print("Integrando F·dr:", integrando)
print("Integral 0 -> pi (CCW):", I_pos)
print("Integral 0 -> -pi (CW):", I_neg)
print("Trabajo en contra 0 -> pi:", W_pos)
print("Trabajo en contra 0 -> -pi:", W_neg)